#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞扫描模块
扫描系统漏洞，包括开放端口、弱认证、不安全协议等
"""

from collections import defaultdict, Counter
from typing import Dict, List, Optional, TYPE_CHECKING

# 类型检查导入（避免循环导入）
if TYPE_CHECKING:
    from ..core.network import NetworkAnalyzer
else:
    NetworkAnalyzer = None

# 导入依赖模块
from ..data.vulnerability_db import VulnerabilityDatabase

class VulnerabilityScanner:
    """系统漏洞扫描器（增强版）"""
    
    def __init__(self, log_entries: List[Dict], network_analyzer: Optional[NetworkAnalyzer] = None, enable_online_db: bool = True):
        self.log_entries = log_entries
        self.network_analyzer = network_analyzer
        self.vulnerabilities = []
        self.vuln_db = VulnerabilityDatabase(enable_online_db=enable_online_db)
    
    def scan_open_ports(self) -> List[Dict]:
        """扫描开放的端口（增强版，使用漏洞数据库）"""
        # 统计被允许的入站连接的目标端口
        allowed_ports = defaultdict(int)
        port_sources = defaultdict(set)  # 记录访问每个端口的源IP
        
        for entry in self.log_entries:
            if entry.get('action') == 'ALLOW' and entry.get('interface_in'):
                dst_port = entry.get('dst_port')
                src_ip = entry.get('src_ip')
                if dst_port:
                    allowed_ports[dst_port] += 1
                    if src_ip:
                        port_sources[dst_port].add(src_ip)
        
        vulnerabilities = []
        for port, count in allowed_ports.items():
            try:
                port_num = int(port)
                port_info = self.vuln_db.get_port_info(port_num)
                
                if port_info:
                    # 判断源IP类型
                    source_type = 'unknown'
                    if port_sources[port]:
                        sample_ip = list(port_sources[port])[0]
                        if self.network_analyzer:
                            ip_type = self.network_analyzer.get_ip_type(sample_ip)
                            if ip_type == 'internet':
                                source_type = 'internet'
                            elif ip_type == 'local':
                                source_type = 'local'
                    
                    vuln = {
                        'type': '开放危险端口',
                        'port': port,
                        'service': port_info['service'],
                        'description': port_info['description'],
                        'access_count': count,
                        'unique_sources': len(port_sources[port]),
                        'source_type': source_type,
                        'severity': port_info['severity'],
                        'common_cves': port_info['common_cves'],
                        'attack_patterns': port_info['attack_patterns'],
                        'recommendation': self._get_recommendation(port_num, port_info)
                    }
                    
                    # 添加增强的CVE信息（如果可用）
                    if 'enhanced_cves' in port_info:
                        vuln['enhanced_cves'] = port_info['enhanced_cves']
                    
                    vulnerabilities.append(vuln)
            except (ValueError, TypeError):
                pass
        
        return vulnerabilities
    
    def scan_weak_authentication(self) -> List[Dict]:
        """扫描弱认证问题（增强版）"""
        vulnerabilities = []
        
        # 检查多个服务的认证失败
        auth_failures = defaultdict(lambda: defaultdict(int))
        auth_services = {
            '22': 'SSH',
            '23': 'Telnet',
            '3306': 'MySQL',
            '5432': 'PostgreSQL',
            '1433': 'MSSQL',
            '3389': 'RDP',
            '5900': 'VNC',
            '6379': 'Redis',
            '27017': 'MongoDB',
            '1521': 'Oracle'
        }
        
        for entry in self.log_entries:
            dst_port = entry.get('dst_port')
            if dst_port and dst_port in auth_services:
                if entry.get('action') in ['BLOCK', 'DENY']:
                    src_ip = entry.get('src_ip')
                    if src_ip:
                        auth_failures[dst_port][src_ip] += 1
        
        for port, failures in auth_failures.items():
            max_failures = max(failures.values()) if failures else 0
            total_failures = sum(failures.values())
            unique_attackers = len(failures)
            
            if max_failures > 10 or total_failures > 50:
                service = auth_services[port]
                port_info = self.vuln_db.get_port_info(int(port))
                
                vuln = {
                    'type': f'{service} 认证风险',
                    'port': port,
                    'service': service,
                    'description': f'检测到 {total_failures} 次 {service} 登录失败尝试，来自 {unique_attackers} 个不同IP',
                    'max_failures_per_ip': max_failures,
                    'total_failures': total_failures,
                    'unique_attackers': unique_attackers,
                    'severity': 'critical' if max_failures > 50 else 'high',
                    'attack_pattern': 'brute_force',
                    'common_cves': port_info['common_cves'] if port_info else [],
                    'recommendation': self._get_authentication_recommendation(port, service)
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def scan_insecure_protocols(self) -> List[Dict]:
        """扫描不安全的协议（增强版）"""
        vulnerabilities = []
        
        # 检查 Telnet (23) 的使用
        telnet_usage = sum(1 for entry in self.log_entries 
                          if entry.get('dst_port') == '23' and entry.get('action') == 'ALLOW')
        
        if telnet_usage > 0:
            port_info = self.vuln_db.get_port_info(23)
            vulnerabilities.append({
                'type': '不安全协议',
                'port': '23',
                'service': 'Telnet',
                'description': '检测到 Telnet 使用（明文传输，易被中间人攻击）',
                'usage_count': telnet_usage,
                'severity': 'critical',
                'common_cves': port_info['common_cves'] if port_info else [],
                'attack_patterns': ['明文传输', '会话劫持', '中间人攻击'],
                'recommendation': '强烈建议：1) 立即禁用 Telnet 2) 使用 SSH (端口 22) 替代 3) 如果必须使用，限制访问来源'
            })
        
        # 检查 HTTP (80) 的使用（未加密）
        http_usage = sum(1 for entry in self.log_entries 
                        if entry.get('dst_port') == '80' and entry.get('action') == 'ALLOW')
        https_usage = sum(1 for entry in self.log_entries 
                         if entry.get('dst_port') == '443' and entry.get('action') == 'ALLOW')
        
        if http_usage > 0 and https_usage == 0:
            port_info = self.vuln_db.get_port_info(80)
            vulnerabilities.append({
                'type': '未加密通信',
                'port': '80',
                'service': 'HTTP',
                'description': '检测到 HTTP 使用但未使用 HTTPS，数据以明文传输',
                'http_usage': http_usage,
                'https_usage': https_usage,
                'severity': 'medium',
                'common_cves': port_info['common_cves'] if port_info else [],
                'attack_patterns': ['数据窃听', '中间人攻击', '会话劫持'],
                'recommendation': '建议：1) 启用 HTTPS (端口 443) 2) 配置 HTTP 到 HTTPS 重定向 3) 使用 HSTS 头'
            })
        
        # 检查 FTP (21) 的使用（未加密）
        ftp_usage = sum(1 for entry in self.log_entries 
                       if entry.get('dst_port') == '21' and entry.get('action') == 'ALLOW')
        if ftp_usage > 0:
            port_info = self.vuln_db.get_port_info(21)
            vulnerabilities.append({
                'type': '不安全协议',
                'port': '21',
                'service': 'FTP',
                'description': '检测到 FTP 使用（可能存在明文传输、弱密码等问题）',
                'usage_count': ftp_usage,
                'severity': 'high',
                'common_cves': port_info['common_cves'] if port_info else [],
                'attack_patterns': port_info['attack_patterns'] if port_info else [],
                'recommendation': '建议：1) 使用 SFTP 或 FTPS 替代 2) 禁用匿名登录 3) 使用强密码 4) 限制访问来源'
            })
        
        return vulnerabilities
    
    def scan_attack_patterns(self) -> List[Dict]:
        """扫描攻击模式特征"""
        vulnerabilities = []
        
        # 检测可能的SQL注入尝试
        sql_keywords = ['union', 'select', 'insert', 'update', 'delete', 'drop', 'exec', 'script']
        sql_injection_attempts = defaultdict(int)
        
        # 检测可能的XSS尝试
        xss_patterns = ['<script', 'javascript:', 'onerror=', 'onload=', 'eval(']
        xss_attempts = defaultdict(int)
        
        # 检测异常流量模式（可能的DoS）
        ip_request_counts = Counter()
        time_window_requests = defaultdict(int)
        
        for entry in self.log_entries:
            src_ip = entry.get('src_ip')
            if src_ip:
                ip_request_counts[src_ip] += 1
            
            # 检查异常高的请求频率（简化版，实际需要时间窗口分析）
            if entry.get('action') in ['BLOCK', 'DENY']:
                src_ip = entry.get('src_ip')
                if src_ip:
                    time_window_requests[src_ip] += 1
        
        # 检测DoS模式
        for ip, count in time_window_requests.items():
            if count > 1000:  # 短时间内大量请求
                if self.network_analyzer:
                    ip_type = self.network_analyzer.get_ip_type(ip)
                    source_type = '互联网' if ip_type == 'internet' else '本地网络'
                else:
                    source_type = '未知'
                
                vulnerabilities.append({
                    'type': '可能的拒绝服务攻击',
                    'source_ip': ip,
                    'source_type': source_type,
                    'description': f'检测到来自 {ip} 的异常高频率请求 ({count} 次被阻止)',
                    'request_count': count,
                    'severity': 'high',
                    'attack_pattern': 'dos',
                    'recommendation': '建议：1) 检查是否为正常流量 2) 考虑实施速率限制 3) 使用 DDoS 防护服务'
                })
        
        return vulnerabilities
    
    def scan_exposed_services(self) -> List[Dict]:
        """扫描暴露的服务（从互联网可访问）"""
        vulnerabilities = []
        
        if not self.network_analyzer:
            return vulnerabilities
        
        # 统计从互联网访问的允许连接
        internet_exposed_ports = defaultdict(int)
        
        for entry in self.log_entries:
            if entry.get('action') == 'ALLOW' and entry.get('interface_in'):
                src_ip = entry.get('src_ip')
                dst_port = entry.get('dst_port')
                
                if src_ip and dst_port:
                    ip_type = self.network_analyzer.get_ip_type(src_ip)
                    if ip_type == 'internet':
                        internet_exposed_ports[dst_port] += 1
        
        for port, count in internet_exposed_ports.items():
            try:
                port_num = int(port)
                port_info = self.vuln_db.get_port_info(port_num)
                
                if port_info and port_info['severity'] in ['high', 'critical']:
                    vulnerabilities.append({
                        'type': '互联网暴露的危险服务',
                        'port': port,
                        'service': port_info['service'],
                        'description': f'{port_info["service"]} 服务从互联网可访问，存在安全风险',
                        'access_count': count,
                        'severity': 'critical',
                        'common_cves': port_info['common_cves'],
                        'attack_patterns': port_info['attack_patterns'],
                        'recommendation': f'强烈建议：1) 限制 {port_info["service"]} 仅允许本地网络访问 2) 使用 VPN 或 SSH 隧道 3) 实施强认证和访问控制'
                    })
            except (ValueError, TypeError):
                pass
        
        return vulnerabilities
    
    def _get_recommendation(self, port: int, port_info: Optional[Dict] = None) -> str:
        """获取端口安全建议（增强版）"""
        base_recommendations = {
            21: '确保 FTP 使用 SFTP 或 FTPS，禁用匿名登录，使用强密码',
            22: '使用密钥认证，禁用密码登录，更改默认端口，使用 fail2ban',
            23: '完全禁用 Telnet，使用 SSH 替代',
            3306: '限制 MySQL 访问，使用强密码，仅允许本地访问，启用 SSL',
            5432: '限制 PostgreSQL 访问，使用强密码，启用 SSL，配置防火墙规则',
            3389: '限制 RDP 访问，使用强密码，考虑使用 VPN，启用网络级认证',
            5900: '限制 VNC 访问，使用强密码，考虑使用 SSH 隧道，启用加密',
            6379: '为 Redis 设置密码，限制网络访问，仅允许本地访问，禁用危险命令',
            27017: '为 MongoDB 启用认证，限制网络访问，使用 SSL/TLS，配置防火墙',
            445: '限制 SMB 访问，禁用 SMBv1，使用强密码，考虑使用 VPN',
            1433: '限制 MSSQL 访问，使用强密码，启用加密，配置防火墙规则',
            1521: '限制 Oracle 访问，使用强密码，启用加密，配置访问控制'
        }
        
        recommendation = base_recommendations.get(port, '检查该端口的访问控制和认证配置')
        
        if port_info and port_info.get('common_cves'):
            cve_list = ', '.join(port_info['common_cves'][:3])  # 显示前3个CVE
            recommendation += f' | 相关CVE: {cve_list}'
        
        return recommendation
    
    def _get_authentication_recommendation(self, port: str, service: str) -> str:
        """获取认证相关建议"""
        recommendations = {
            'SSH': '1) 禁用密码登录，仅使用密钥认证 2) 更改默认端口 3) 使用 fail2ban 防护 4) 限制允许登录的用户',
            'MySQL': '1) 使用强密码策略 2) 限制访问来源IP 3) 启用 SSL/TLS 4) 定期更新数据库',
            'PostgreSQL': '1) 使用强密码 2) 启用 SSL 3) 配置 pg_hba.conf 限制访问 4) 使用防火墙规则',
            'MSSQL': '1) 使用强密码 2) 启用加密 3) 限制访问来源 4) 定期更新补丁',
            'RDP': '1) 使用强密码 2) 启用网络级认证 3) 考虑使用 VPN 4) 限制访问来源IP',
            'VNC': '1) 使用强密码 2) 启用加密 3) 考虑使用 SSH 隧道 4) 限制访问来源',
            'Redis': '1) 设置强密码 2) 禁用危险命令 3) 仅允许本地访问 4) 使用防火墙规则',
            'MongoDB': '1) 启用认证 2) 使用强密码 3) 启用 SSL/TLS 4) 限制网络访问',
            'Oracle': '1) 使用强密码 2) 启用加密 3) 限制访问来源 4) 定期更新补丁'
        }
        
        return recommendations.get(service, '实施强认证策略，限制访问来源，定期更新补丁')
    
    def scan_all_vulnerabilities(self) -> List['VulnerabilityResult']:
        """扫描所有漏洞（增强版）"""
        all_vulns = []
        all_vulns.extend(self.scan_open_ports())
        all_vulns.extend(self.scan_weak_authentication())
        all_vulns.extend(self.scan_insecure_protocols())
        all_vulns.extend(self.scan_attack_patterns())
        all_vulns.extend(self.scan_exposed_services())
        
        # 按严重程度排序
        severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        all_vulns.sort(key=lambda x: severity_order.get(x.get('severity', 'low'), 3))
        
        self.vulnerabilities = all_vulns
        return all_vulns


